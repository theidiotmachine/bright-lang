use crate::ClosureRef;
use bright_lang_types::TraitMemberFunc;
use bright_lang_types::Type;
use serde::{Serialize, Deserialize};

use bright_lang_errs::source_location::SourceLocation;
use bright_lang_types::{QualifiedType, Mutability};

use crate::FuncDefn;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Copy)]
pub enum BinaryOperator{
    As,
    Divide,
    Dot,
    Equal,
    GreaterThan,
    GreaterThanEqual,
    In,
    LessThan,
    LessThanEqual,
    LogicalAnd,
    LogicalOr,
    Minus,
    Mod,
    Multiply,
    NotEqual,
    Plus,
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum UnaryOperator{
    LogicalNot,
    PostfixIncrement,
    PostfixDecrement,
    Minus,
    Plus,
    PrefixIncrement,
    PrefixDecrement,
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum AssignmentOperator{
    Assign,
    PlusAssign,
    MinusAssign,
    MultiplyAssign,
    DivideAssign,
    ModAssign,
}

/// Function declaration. This means a declaration site. In reality that means a closure creation plus 
/// reference to table pointer if it's consumed.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FuncObjectCreation {
    pub name: String,
    pub closure: Vec<ClosureRef>
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Intrinsic {
    ///memory.grow
    MemoryGrow(NodeIdx),
    ///memory.size
    MemorySize,
    ///unreachable
    Trap,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ObjectLiteralElem{
    pub name: String,
    pub value: NodeIdx,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Copy)]
pub struct NodeIdx{
    pub p: usize
}

impl NodeIdx{
    pub fn new(p: usize) -> NodeIdx {
        NodeIdx{p}
    }

    pub const NULL: NodeIdx = NodeIdx{p: usize::MAX};
}

/// Something that returns something. This is really an RValue.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Expr {
    /// Array literal constructor; e.g. `[1, 2, 3]`
    /// Full syntax is `Type[...]` where `Type` defaults to `Array<T>` where `T` is
    /// guessed from the elements.
    ArrayConstructor{r#type: Type, args: Vec<NodeIdx>},
    /// Simple assignment expression that can use the built in variable assignment. 
    Assignment{l_value: NodeIdx, r_value: NodeIdx},
    /// A binary operator
    BinaryOperator{lhs: NodeIdx, rhs: NodeIdx, op: BinaryOperator},
    /// A block of code. In code this is a set of statements surrounded by squigglies.
    /// The last instruction will be an `End`. The `last` element points to the instruction before the `End`.
    Block{first: NodeIdx, last: NodeIdx},
    /// True or False
    BoolLiteral(bool),
    /// break
    Break,
    /// class decl
    ClassDecl{class_name: String},
    /// object constructor
    Constructor{r#type: QualifiedType, args: Vec<ObjectLiteralElem>},
    /// continue
    Continue,
    /// A deep copy. May be elided out.
    DeepCopy{expr: NodeIdx},
    /// Member of a thing, such as a[b]
    DynamicMember{object: NodeIdx, member: NodeIdx},
    //Assign a dynamic member of some data e.g. a[b] = c
    DynamicMemberLValue{object: NodeIdx, member: NodeIdx},
    /// float literal
    FloatLiteral(f64),
    /// A type narrow that has no runtime cost. Generated by guard code.
    FreeDowncast(NodeIdx),
    /// A type widen that has no runtime cost. Used to make the types of the AST correct
    FreeUpcast(NodeIdx),
    /// a function declaration. This might compile to a closure creation, a function pointer, or a no op 
    FuncDecl(FuncObjectCreation),
    //Assign a global variable
    GlobalVariableLValue(String),
    ///global variable use
    GlobalVariableUse(String),
    /// if-then
    IfThen{cond: NodeIdx, then: NodeIdx},
    /// if-then-else
    IfThenElse{cond: NodeIdx, then: NodeIdx, r#else: NodeIdx},
    /// Int literal
    IntLiteral(i128),
    /// Implicit i32 -> f64 cast
    IntToNumber(NodeIdx),
    /// A single wasm instruction. 
    Intrinsic(Intrinsic),
    /// Int widen. May be free, may end up being i32 -> i64
    IntWiden(NodeIdx),
    /// Local variable declaration
    LocalVariableInit{internal_name: String, init: NodeIdx},
    //Assign a local variable
    LocalVariableLValue(String),
    ///local variable use
    LocalVariableUse(String),
    /// Modify and assign expression, so for example `a *= b`. 
    /// Compiles down to `l = l op r`, which means the left hand side appears twice, once as 
    /// an l_value and once as an r_value.
    ModifyAssignment{op: AssignmentOperator, lhs: NodeIdx, l_value: NodeIdx, rhs: NodeIdx},
    /// Member of a thing, such as a.b
    NamedMember{object: Box<TypedExpr>, member: String},
    //Assign a static named member of some data, so e.g. a.b = c
    NamedMemberLValue{object: NodeIdx, member: String},
    ///round brackets used for parens
    PrecedenceParens(NodeIdx),
    /// Member func call.
    MemberFuncCall{this_expr: NodeIdx, func_name: String, args: Vec<NodeIdx>},
    ///No op expression. Exists generally for error recovery. Not generated by user.
    NoOp,
    ///qualified type literal
    QualifiedTypeLiteral(QualifiedType),
    /// return statement
    Return(Option<NodeIdx>),
    /// static func call. 
    StaticFuncCall{func_name: String, func_defn: FuncDefn, args: Vec<NodeIdx>},
    ///string literal
    StringLiteral(String),
    ///A trait function call
    TraitMemberFuncCall{trait_member_func: TraitMemberFunc, this_expr: NodeIdx, args: Vec<NodeIdx>},
    ///Tuple constructor or literal
    TupleConstructor{elems: Vec<NodeIdx>},
    ///type literal
    TypeLiteral(Type),
    /// unary operator
    UnaryOperator{expr: usize, op: UnaryOperator},
    /// A generic call that we haven't been able to resolve yet
    UnresolvedGenericFuncCall{func_name: String, unresolved_func_defn: FuncDefn, args: Vec<NodeIdx>, unresolved_types: Vec<Type>},
    /// Variable declaration where we don't know what the type is
    UnresolvedLocalVariableInit{internal_name: String, var_type: QualifiedType, init: NodeIdx},
    ///void. Unlike TS we use void as the unit type, so you can instantiate it.
    Void,
    /// while loop
    While{cond: NodeIdx, body: NodeIdx},
}

impl Expr{
    pub fn is_literal(&self, arena: &Arena) -> bool {
        match self {
            Expr::FloatLiteral(_) | Expr::IntLiteral(_) | Expr::BoolLiteral(_) 
                | Expr::Void | Expr::StringLiteral(_) | Expr::TypeLiteral(_) 
                => true,
            Expr::TupleConstructor{elems} => {
                elems.iter().all(|&x| arena.a[x.p].expr.is_literal(arena))
            },
            Expr::ArrayConstructor{r#type: _, args} => {
                args.iter().all(|&x| arena.a[x.p].expr.is_literal(arena))
            },
            _ => false
        }
    }
}

/// If this expr returns something, is it a func end or a block end?
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum ReturnExpr {
    None,
    Block,
    Func
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Arena{
    pub a: Vec<TypedExpr>,
}

impl Default for Arena {
    fn default() -> Self {
        Self::new()
    }
}

impl Arena{
    pub fn new() -> Arena {
        Arena{a: vec![]}
    }

    pub fn new_block(loc: SourceLocation) -> Arena {
        Arena{a: vec![
            TypedExpr{
                expr: Expr::Block{first: NodeIdx::NULL, last: NodeIdx::NULL},
                loc,
                next: NodeIdx::NULL,
                return_expr: ReturnExpr::None,
                r#type: QualifiedType::new_const(&Type::Undeclared)
            }
        ]}
    }

    pub fn set_return_expr(&mut self, p: NodeIdx, return_expr: ReturnExpr)  {
        match self.a[p.p].expr {
            Expr::Block{first: _, last} => {
                self.set_return_expr(last, return_expr);
            },
            Expr::IfThenElse{cond: _, then: tte, r#else: ete} => {
                self.set_return_expr(tte, return_expr);
                self.set_return_expr(ete, return_expr);
            },
            _ => {}
        }
        self.a[p.p].return_expr = return_expr;
    }

    pub fn push_np_to_block(&mut self, block_ptr: NodeIdx, np: NodeIdx) {
        let block_expr = &self.a[block_ptr.p].expr;
        let (first, last) = match block_expr {
            Expr::Block{first, last} => {
                let first = if *first == NodeIdx::NULL {
                    np
                } else {
                    *first
                };
                
                (first, *last)
            },
            _ => unreachable!()
        };

        if last != NodeIdx::NULL {
            self.a[last.p].next = np;
        }
        self.a[block_ptr.p].expr = Expr::Block{first, last: np};   
    }

    pub fn close_block(&mut self, loc: SourceLocation, block_ptr: NodeIdx) {
        self.a[block_ptr.p].loc.extend_end_position(loc.end);
        let block_expr = &self.a[block_ptr.p].expr;
        let last = match block_expr {
            Expr::Block{first: _, last} => {
                *last
            },
            _ => unreachable!()
        };
        if last != NodeIdx::NULL {
            self.a[block_ptr.p].r#type = self.a[last.p].r#type.clone();
        }
    }

    pub fn push_block(&mut self, loc: SourceLocation) -> NodeIdx {
        let len = self.a.len();
        self.a.push(TypedExpr{
            expr: Expr::Block{first: NodeIdx::NULL, last: NodeIdx::NULL},
            loc,
            next: NodeIdx::NULL,
            return_expr: ReturnExpr::None,
            r#type: QualifiedType::new_const(&Type::Undeclared)
        });
        NodeIdx{p: len}
    }

    pub fn push(&mut self, te: TypedExpr) -> NodeIdx {
        let len = self.a.len();
        self.push(te);
        NodeIdx{p: len}
    }
}

/// The main expression class.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TypedExpr{
    pub expr: Expr,
    pub r#type: QualifiedType,
    pub loc: SourceLocation,
    pub return_expr: ReturnExpr,
    pub next: NodeIdx,
}

impl TypedExpr{
    pub fn new(expr: &Expr,
        r#type: &QualifiedType,
        loc: SourceLocation
    ) -> TypedExpr {
        TypedExpr {
            expr: expr.clone(), 
            r#type: r#type.clone(), 
            loc, return_expr: ReturnExpr::None, 
            next: NodeIdx::NULL
        } 
    }

    pub fn type_is_const(&self) -> bool {
        self.r#type.mutability == Mutability::Const
    }
}
