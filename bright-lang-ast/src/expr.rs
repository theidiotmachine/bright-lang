use bright_lang_types::TraitMemberFunc;
use bright_lang_types::Type;
use serde::{Serialize, Deserialize};

use bright_lang_errs::source_location::SourceLocation;
use bright_lang_types::{QualifiedType, Mutability};

use crate::FuncDefn;

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Copy)]
pub enum BinaryOperator{
    As,
    Divide,
    Dot,
    Equal,
    GreaterThan,
    GreaterThanEqual,
    In,
    LessThan,
    LessThanEqual,
    LogicalAnd,
    LogicalOr,
    Minus,
    Mod,
    Multiply,
    NotEqual,
    Plus,
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum UnaryOperator{
    LogicalNot,
    PostfixIncrement,
    PostfixDecrement,
    Minus,
    Plus,
    PrefixIncrement,
    PrefixDecrement,
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum AssignmentOperator{
    Assign,
    PlusAssign,
    MinusAssign,
    MultiplyAssign,
    DivideAssign,
    ModAssign,
}

/// Function declaration. This means a declaration site. In reality that means a closure creation plus 
/// reference to table pointer if it's consumed.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FuncObjectCreation {
    pub name: String,
    //pub closure: Vec<ClosureRef>
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Intrinsic {
    ///memory.grow
    MemoryGrow(NodePtr),
    ///memory.size
    MemorySize,
    ///unreachable
    Trap,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ObjectLiteralElem{
    pub name: String,
    pub value: NodePtr,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Copy)]
pub struct NodePtr{
    pub p: usize
}

/// Something that returns something. This is really an RValue.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Expr {
    /// Array literal constructor; e.g. `[1, 2, 3]`
    /// Full syntax is `Type[...]` where `Type` defaults to `Array<T>` where `T` is
    /// guessed from the elements.
    ArrayConstructor{r#type: Type, args: Vec<NodePtr>},
    /// Simple assignment expression that can use the built in variable assignment. 
    Assignment{l_value: NodePtr, r_value: NodePtr},
    /// A binary operator
    BinaryOperator{lhs: NodePtr, rhs: NodePtr, op: BinaryOperator},
    /// A block of code. In code this is a set of statements surrounded by squigglies.
    /// The last instruction will be an `End`. The `last` element points to the instruction before the `End`.
    Block{first: NodePtr, last: NodePtr},
    /// True or False
    BoolLiteral(bool),
    /// break
    Break,
    /// class decl
    ClassDecl{class_name: String},
    /// object constructor
    Constructor{r#type: QualifiedType, args: Vec<ObjectLiteralElem>},
    /// continue
    Continue,
    /// Block end. Part of the IR, not turned into WASM
    End,
    /// A deep copy. May be elided out.
    DeepCopy{expr: NodePtr},
    /// Member of a thing, such as a[b]
    DynamicMember{object: NodePtr, member: NodePtr},
    //Assign a dynamic member of some data e.g. a[b] = c
    DynamicMemberLValue{object: NodePtr, member: NodePtr},
    /// float literal
    FloatLiteral(f64),
    /// A type narrow that has no runtime cost. Generated by guard code.
    FreeDowncast(NodePtr),
    /// A type widen that has no runtime cost. Used to make the types of the AST correct
    FreeUpcast(NodePtr),
    /// a function declaration. This might compile to a closure creation, a function pointer, or a no op 
    FuncDecl(FuncObjectCreation),
    //Assign a global variable
    GlobalVariableLValue(String),
    ///global variable use
    GlobalVariableUse(String),
    /// if-then
    IfThen{cond: NodePtr, then: NodePtr},
    /// if-then-else
    IfThenElse{cond: NodePtr, then: NodePtr, r#else: NodePtr},
    /// Int literal
    IntLiteral(i128),
    /// Implicit i32 -> f64 cast
    IntToNumber(NodePtr),
    /// A single wasm instruction. 
    Intrinsic(Intrinsic),
    /// Int widen. May be free, may end up being i32 -> i64
    IntWiden(NodePtr),
    /// Local variable declaration
    LocalVariableInit{internal_name: String, init: NodePtr},
    //Assign a local variable
    LocalVariableLValue(String),
    ///local variable use
    LocalVariableUse(String),
    /// Modify and assign expression, so for example `a *= b`. 
    /// Compiles down to `l = l op r`, which means the left hand side appears twice, once as 
    /// an l_value and once as an r_value.
    ModifyAssignment{op: AssignmentOperator, lhs: NodePtr, l_value: NodePtr, rhs: NodePtr},
    /// Member of a thing, such as a.b
    NamedMember{object: Box<TypedExpr>, member: String},
    //Assign a static named member of some data, so e.g. a.b = c
    NamedMemberLValue{object: NodePtr, member: String},
    ///round brackets used for parens
    PrecedenceParens(NodePtr),
    /// Member func call.
    MemberFuncCall{this_expr: NodePtr, func_name: String, args: Vec<NodePtr>},
    ///No op expression. Exists generally for error recovery. Not generated by user.
    NoOp,
    ///qualified type literal
    QualifiedTypeLiteral(QualifiedType),
    /// return statement
    Return(Option<NodePtr>),
    /// static func call. 
    StaticFuncCall{func_name: String, func_defn: FuncDefn, args: Vec<NodePtr>},
    ///string literal
    StringLiteral(String),
    ///A trait function call
    TraitMemberFuncCall{trait_member_func: TraitMemberFunc, this_expr: NodePtr, args: Vec<NodePtr>},
    ///Tuple constructor or literal
    TupleConstructor{elems: Vec<NodePtr>},
    ///type literal
    TypeLiteral(Type),
    /// unary operator
    UnaryOperator{expr: usize, op: UnaryOperator},
    /// A generic call that we haven't been able to resolve yet
    UnresolvedGenericFuncCall{func_name: String, unresolved_func_defn: FuncDefn, args: Vec<NodePtr>, unresolved_types: Vec<Type>},
    /// Variable declaration where we don't know what the type is
    UnresolvedLocalVariableInit{internal_name: String, var_type: QualifiedType, init: NodePtr},
    ///void. Unlike TS we use void as the unit type, so you can instantiate it.
    Void,
    /// while loop
    While{cond: NodePtr, body: NodePtr},
}

impl Expr{
    pub fn is_literal(&self, arena: &Arena) -> bool {
        match self {
            Expr::FloatLiteral(_) | Expr::IntLiteral(_) | Expr::BoolLiteral(_) 
                | Expr::Void | Expr::StringLiteral(_) | Expr::TypeLiteral(_) 
                => true,
            Expr::TupleConstructor{elems} => {
                elems.iter().all(|&x| arena.a[x.p].expr.is_literal(arena))
            },
            Expr::ArrayConstructor{r#type: _, args} => {
                args.iter().all(|&x| arena.a[x.p].expr.is_literal(arena))
            },
            _ => false
        }
    }
}

/// If this expr returns something, is it a func end or a block end?
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum ReturnExpr {
    None,
    Block,
    Func
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Arena{
    pub a: Vec<TypedExpr>
}

impl Arena{
    pub fn set_return_expr(&mut self, p: NodePtr, return_expr: ReturnExpr) -> () {
        match self.a[p.p].expr {
            Expr::Block{first: first, last: last} => {
                self.set_return_expr(last, return_expr);
            },
            Expr::IfThenElse{cond: _, then: tte, r#else: ete} => {
                self.set_return_expr(tte, return_expr);
                self.set_return_expr(ete, return_expr);
            },
            _ => {}
        }
        self.a[p.p].return_expr = return_expr;
    }
}

/// The main expression class.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TypedExpr{
    pub expr: Expr,
    pub r#type: QualifiedType,
    pub loc: SourceLocation,
    pub return_expr: ReturnExpr,
    pub next: usize,
}

impl TypedExpr{
    pub fn type_is_const(&self) -> bool {
        self.r#type.mutability == Mutability::Const
    }
}
